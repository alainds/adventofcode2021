{"ast":null,"code":"import { input } from \"data/input22\";\nimport { arraysEqual, reducerSum } from \"util/array\";\n\nfunction result1() {\n  return getWinnerScore(play(getData()));\n}\n\nfunction result2() {\n  return getWinnerScore(playSub(getData()));\n}\n\nexport default function getResultats() {\n  return [result1(), result2()];\n}\n\nfunction play(decks) {\n  while (decks.player1.length > 0 && decks.player2.length > 0) {\n    decks = oneTurn(decks);\n  }\n\n  return decks;\n}\n\nfunction getWinnerScore(decks) {\n  const winner = decks.player1.length === 0 ? decks.player2 : decks.player1;\n  console.log(\"END\");\n  console.log({\n    decks\n  });\n  return winner.reverse().map((a, i) => a * (i + 1)).reduce(reducerSum);\n}\n\nfunction oneTurn(decks) {\n  let {\n    player1,\n    player2\n  } = decks;\n  const card1 = player1.splice(0, 1)[0];\n  const card2 = player2.splice(0, 1)[0];\n\n  if (card1 > card2) {\n    player1.push(card1);\n    player1.push(card2);\n  } else {\n    player2.push(card2);\n    player2.push(card1);\n  }\n\n  return {\n    player1,\n    player2\n  };\n}\n\nfunction oneTurnWithWinner(decks, isPlayer1Wins) {\n  let {\n    player1,\n    player2\n  } = decks;\n  const card1 = player1.splice(0, 1)[0];\n  const card2 = player2.splice(0, 1)[0];\n\n  if (isPlayer1Wins) {\n    player1.push(card1);\n    player1.push(card2);\n  } else {\n    player2.push(card2);\n    player2.push(card1);\n  }\n\n  return {\n    player1,\n    player2\n  };\n}\n\nfunction removeCards(decks) {\n  const {\n    player1,\n    player2\n  } = decks;\n  return {\n    player1: player1.slice(1, player1[0] + 1),\n    player2: player2.slice(1, player2[0] + 1)\n  };\n}\n\nfunction playSub(decksInput, game = 1) {\n  let nnnn = 0;\n  const turns = [];\n  let isPlayer1WinsExist = false;\n  let decks = JSON.parse(JSON.stringify(decksInput));\n\n  while (decks.player1.length > 0 && decks.player2.length > 0 && !isPlayer1WinsExist) {\n    nnnn++;\n    const decksBefore = JSON.parse(JSON.stringify(decks));\n    isPlayer1WinsExist = isDecksExistedBefore(decks, turns);\n    turns.push(decksBefore);\n    decks = oneTurnSub(decks);\n\n    if (isPlayer1WinsExist) {\n      return true;\n    } else if (arraysEqual(decks.player1, decksBefore.player1) && arraysEqual(decks.player2, decksBefore.player2)) {\n      debugger;\n      const isPlayer1Wins = playSub(removeCards(decks), game + 1);\n      decks = oneTurnWithWinner(decks, isPlayer1Wins);\n    }\n  }\n\n  if (game === 1) {\n    return decks;\n  } else {\n    return decks.player2.length === 0;\n  }\n}\n\nfunction isDecksExistedBefore(decks, turns) {\n  for (let index = 0; index < turns.length; index++) {\n    const element = turns[index];\n\n    if (arraysEqual(decks.player1, element.player1) && arraysEqual(decks.player2, element.player2)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction oneTurnSub(decks) {\n  let {\n    player1,\n    player2\n  } = decks;\n  const card1 = player1[0];\n  const card2 = player2[0];\n\n  if (player1.length > card1 && player2.length > card2) {\n    return decks;\n  }\n\n  player1.splice(0, 1);\n  player2.splice(0, 1);\n\n  if (card1 > card2) {\n    player1.push(card1);\n    player1.push(card2);\n  } else {\n    player2.push(card2);\n    player2.push(card1);\n  }\n\n  return {\n    player1,\n    player2\n  };\n}\n\nfunction getData() {\n  const players = input.split(\"\\n\\n\").map(a => a.split(\"\\n\").filter(b => b.substr(0, 1) !== \"P\").map(b => parseInt(b)));\n  return {\n    player1: players[0],\n    player2: players[1]\n  };\n}","map":{"version":3,"sources":["d:/Dev/adventofcode2021/src/days/jour22.js"],"names":["input","arraysEqual","reducerSum","result1","getWinnerScore","play","getData","result2","playSub","getResultats","decks","player1","length","player2","oneTurn","winner","console","log","reverse","map","a","i","reduce","card1","splice","card2","push","oneTurnWithWinner","isPlayer1Wins","removeCards","slice","decksInput","game","nnnn","turns","isPlayer1WinsExist","JSON","parse","stringify","decksBefore","isDecksExistedBefore","oneTurnSub","index","element","players","split","filter","b","substr","parseInt"],"mappings":"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","sourcesContent":["import { input } from \"data/input22\"\r\nimport { arraysEqual, reducerSum } from \"util/array\"\r\n\r\nfunction result1() {\r\n  return getWinnerScore(play(getData()))\r\n}\r\n\r\nfunction result2() {\r\n  return getWinnerScore(playSub(getData()))\r\n}\r\n\r\nexport default function getResultats() {\r\n  return [result1(), result2()]\r\n}\r\nfunction play(decks) {\r\n  while (decks.player1.length > 0 && decks.player2.length > 0) {\r\n    decks = oneTurn(decks)\r\n  }\r\n  return decks\r\n}\r\nfunction getWinnerScore(decks) {\r\n  const winner = decks.player1.length === 0 ? decks.player2 : decks.player1\r\n\r\n  console.log(\"END\")\r\n  console.log({ decks })\r\n  return winner\r\n    .reverse()\r\n    .map((a, i) => a * (i + 1))\r\n    .reduce(reducerSum)\r\n}\r\n\r\nfunction oneTurn(decks) {\r\n  let { player1, player2 } = decks\r\n  const card1 = player1.splice(0, 1)[0]\r\n  const card2 = player2.splice(0, 1)[0]\r\n  if (card1 > card2) {\r\n    player1.push(card1)\r\n    player1.push(card2)\r\n  } else {\r\n    player2.push(card2)\r\n    player2.push(card1)\r\n  }\r\n  return { player1, player2 }\r\n}\r\n\r\nfunction oneTurnWithWinner(decks, isPlayer1Wins) {\r\n  let { player1, player2 } = decks\r\n  const card1 = player1.splice(0, 1)[0]\r\n  const card2 = player2.splice(0, 1)[0]\r\n  if (isPlayer1Wins) {\r\n    player1.push(card1)\r\n    player1.push(card2)\r\n  } else {\r\n    player2.push(card2)\r\n    player2.push(card1)\r\n  }\r\n  return { player1, player2 }\r\n}\r\n\r\nfunction removeCards(decks) {\r\n  const { player1, player2 } = decks\r\n\r\n  return {\r\n    player1: player1.slice(1, player1[0] + 1),\r\n    player2: player2.slice(1, player2[0] + 1),\r\n  }\r\n}\r\n\r\nfunction playSub(decksInput, game = 1) {\r\n  let nnnn = 0\r\n  const turns = []\r\n  let isPlayer1WinsExist = false\r\n  let decks = JSON.parse(JSON.stringify(decksInput))\r\n  while (\r\n    decks.player1.length > 0 &&\r\n    decks.player2.length > 0 &&\r\n    !isPlayer1WinsExist\r\n  ) {\r\n    nnnn++\r\n    const decksBefore = JSON.parse(JSON.stringify(decks))\r\n    isPlayer1WinsExist = isDecksExistedBefore(decks, turns)\r\n    turns.push(decksBefore)\r\n    decks = oneTurnSub(decks)\r\n    if (isPlayer1WinsExist) {\r\n      return true\r\n    } else if (\r\n      arraysEqual(decks.player1, decksBefore.player1) &&\r\n      arraysEqual(decks.player2, decksBefore.player2)\r\n    ) {\r\n      debugger\r\n      const isPlayer1Wins = playSub(removeCards(decks), game + 1)\r\n      decks = oneTurnWithWinner(decks, isPlayer1Wins)\r\n    }\r\n  }\r\n  if (game === 1) {\r\n    return decks\r\n  } else {\r\n    return decks.player2.length === 0\r\n  }\r\n}\r\nfunction isDecksExistedBefore(decks, turns) {\r\n  for (let index = 0; index < turns.length; index++) {\r\n    const element = turns[index]\r\n    if (\r\n      arraysEqual(decks.player1, element.player1) &&\r\n      arraysEqual(decks.player2, element.player2)\r\n    ) {\r\n      return true\r\n    }\r\n  }\r\n  return false\r\n}\r\nfunction oneTurnSub(decks) {\r\n  let { player1, player2 } = decks\r\n  const card1 = player1[0]\r\n  const card2 = player2[0]\r\n  if (player1.length > card1 && player2.length > card2) {\r\n    return decks\r\n  }\r\n  player1.splice(0, 1)\r\n  player2.splice(0, 1)\r\n\r\n  if (card1 > card2) {\r\n    player1.push(card1)\r\n    player1.push(card2)\r\n  } else {\r\n    player2.push(card2)\r\n    player2.push(card1)\r\n  }\r\n  return { player1, player2 }\r\n}\r\n\r\nfunction getData() {\r\n  const players = input.split(\"\\n\\n\").map((a) =>\r\n    a\r\n      .split(\"\\n\")\r\n      .filter((b) => b.substr(0, 1) !== \"P\")\r\n      .map((b) => parseInt(b))\r\n  )\r\n  return { player1: players[0], player2: players[1] }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}