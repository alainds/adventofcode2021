{"ast":null,"code":"import { input } from \"data/input18\";\nimport { reducerMultiply, reducerSum } from \"util/array\";\n\nfunction result1() {\n  const operations = getData();\n  return operations.map(op => calcul(op)).reduce(reducerSum);\n}\n\nfunction result2() {\n  const operations = getData();\n  return operations.map(op => calcul(op, calculSimpleAdd)).reduce(reducerSum);\n}\n\nexport default function getResultats() {\n  return [result1(), result2()];\n}\n\nfunction calculSimpleAdd(operationString) {\n  const regexOp = /[*+]/;\n  const regexNumber = /[0-9]/g;\n  const numbers = operationString.split(regexOp).map(a => parseInt(a));\n  const addMults = operationString.replaceAll(regexNumber, \"\").split(\"\");\n  let adds = addMults.map((type, i) => {\n    return {\n      type,\n      i\n    };\n  }).filter(o => o.type === \"+\");\n  let newNumbers = [...numbers];\n  let result = 0;\n\n  for (let index = 0; index < adds.length; index++) {\n    const add = adds[index];\n    const nextAdd = adds[index + 1];\n    const previousAdd = adds[index - 1];\n    const hasPreviousAdd = previousAdd && add.i - previousAdd.i === 1;\n    const hasNextAdd = nextAdd && nextAdd.i - add.i === 1;\n    result = hasPreviousAdd ? result + numbers[add.i + 1] : numbers[add.i] + numbers[add.i + 1];\n    newNumbers.splice(add.i, 1, 1);\n    newNumbers.splice(add.i + 1, 1, result);\n    result = hasNextAdd ? result : 0;\n  }\n\n  const resultFin = newNumbers.reduce(reducerMultiply);\n  return resultFin;\n}\n\nfunction calculSimple(operationString) {\n  const regexOp = /[*+]/;\n  const regexNumber = /[0-9]/g;\n  const numbers = operationString.split(regexOp);\n  const addMults = operationString.replaceAll(regexNumber, \"\").split(\"\");\n  let result = parseInt(numbers[0]);\n  numbers.splice(0, 1);\n\n  for (let index = 0; index < numbers.length; index++) {\n    const element = numbers[index];\n    result = addMults[index] === \"*\" ? parseInt(element) * result : parseInt(element) + result;\n  }\n\n  return result;\n}\n\nfunction calcul(operation, calculSimpleFunc = calculSimple) {\n  if (!operation.includes(\"(\")) {\n    return calculSimpleFunc(operation);\n  } else {\n    const regexBrace = /\\(([^(^)]+)\\)/;\n    const operationInBracket = regexBrace.exec(operation)[1];\n    return calcul(operation.replace(regexBrace, calcul(operationInBracket, calculSimpleFunc)), calculSimpleFunc);\n  }\n}\n\nfunction getData() {\n  return input.split(\"\\n\").map(a => a.replaceAll(\" \", \"\"));\n}","map":{"version":3,"sources":["d:/Dev/adventofcode2021/src/days/jour18.js"],"names":["input","reducerMultiply","reducerSum","result1","operations","getData","map","op","calcul","reduce","result2","calculSimpleAdd","getResultats","operationString","regexOp","regexNumber","numbers","split","a","parseInt","addMults","replaceAll","adds","type","i","filter","o","newNumbers","result","index","length","add","nextAdd","previousAdd","hasPreviousAdd","hasNextAdd","splice","resultFin","calculSimple","element","operation","calculSimpleFunc","includes","regexBrace","operationInBracket","exec","replace"],"mappings":"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","sourcesContent":["import { input } from \"data/input18\"\r\nimport { reducerMultiply, reducerSum } from \"util/array\"\r\n\r\nfunction result1() {\r\n  const operations = getData()\r\n  return operations.map((op) => calcul(op)).reduce(reducerSum)\r\n}\r\n\r\nfunction result2() {\r\n  const operations = getData()\r\n  return operations.map((op) => calcul(op, calculSimpleAdd)).reduce(reducerSum)\r\n}\r\n\r\nexport default function getResultats() {\r\n  return [result1(), result2()]\r\n}\r\n\r\nfunction calculSimpleAdd(operationString) {\r\n  const regexOp = /[*+]/\r\n  const regexNumber = /[0-9]/g\r\n  const numbers = operationString.split(regexOp).map((a) => parseInt(a))\r\n  const addMults = operationString.replaceAll(regexNumber, \"\").split(\"\")\r\n  let adds = addMults\r\n    .map((type, i) => {\r\n      return {\r\n        type,\r\n        i,\r\n      }\r\n    })\r\n    .filter((o) => o.type === \"+\")\r\n  let newNumbers = [...numbers]\r\n  let result = 0\r\n  for (let index = 0; index < adds.length; index++) {\r\n    const add = adds[index]\r\n    const nextAdd = adds[index + 1]\r\n    const previousAdd = adds[index - 1]\r\n    const hasPreviousAdd = previousAdd && add.i - previousAdd.i === 1\r\n    const hasNextAdd = nextAdd && nextAdd.i - add.i === 1\r\n    result = hasPreviousAdd\r\n      ? result + numbers[add.i + 1]\r\n      : numbers[add.i] + numbers[add.i + 1]\r\n    newNumbers.splice(add.i, 1, 1)\r\n    newNumbers.splice(add.i + 1, 1, result)\r\n    result = hasNextAdd ? result : 0\r\n  }\r\n  const resultFin = newNumbers.reduce(reducerMultiply)\r\n\r\n  return resultFin\r\n}\r\n\r\nfunction calculSimple(operationString) {\r\n  const regexOp = /[*+]/\r\n  const regexNumber = /[0-9]/g\r\n  const numbers = operationString.split(regexOp)\r\n  const addMults = operationString.replaceAll(regexNumber, \"\").split(\"\")\r\n  let result = parseInt(numbers[0])\r\n  numbers.splice(0, 1)\r\n  for (let index = 0; index < numbers.length; index++) {\r\n    const element = numbers[index]\r\n    result =\r\n      addMults[index] === \"*\"\r\n        ? parseInt(element) * result\r\n        : parseInt(element) + result\r\n  }\r\n  return result\r\n}\r\n\r\nfunction calcul(operation, calculSimpleFunc = calculSimple) {\r\n  if (!operation.includes(\"(\")) {\r\n    return calculSimpleFunc(operation)\r\n  } else {\r\n    const regexBrace = /\\(([^(^)]+)\\)/\r\n    const operationInBracket = regexBrace.exec(operation)[1]\r\n    return calcul(\r\n      operation.replace(\r\n        regexBrace,\r\n        calcul(operationInBracket, calculSimpleFunc)\r\n      ),\r\n      calculSimpleFunc\r\n    )\r\n  }\r\n}\r\n\r\nfunction getData() {\r\n  return input.split(\"\\n\").map((a) => a.replaceAll(\" \", \"\"))\r\n}\r\n"]},"metadata":{},"sourceType":"module"}