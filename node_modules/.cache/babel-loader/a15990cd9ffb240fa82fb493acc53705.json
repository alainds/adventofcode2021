{"ast":null,"code":"import { input } from \"data/input23\";\nimport { arrayRotate } from \"util/array\";\n\nfunction result1() {\n  const cups = getData();\n  let cupsMoved = [...cups];\n  const NBMOVES = 10000000;\n\n  for (let index = 0; index < NBMOVES; index++) {\n    cupsMoved = doOneMove(cupsMoved, index % cups.length);\n  }\n\n  while (cupsMoved[0] !== 1) {\n    cupsMoved = arrayRotate(cupsMoved, true);\n  }\n\n  return cupsMoved.join(\"\");\n}\n\nfunction result2() {\n  return;\n}\n\nexport default function getResultats() {\n  return [result1(), result2()];\n}\n\nfunction getData() {\n  return input.split(\"\").map(a => parseInt(a));\n}\n\nfunction doOneMove(cups, currentPosition) {\n  const cupsLength = cups.length;\n  const minCup = Math.min(...cups);\n  const maxCup = Math.max(...cups);\n  const currentCup = cups[currentPosition];\n  let destination = currentCup - 1 < minCup ? maxCup : currentCup - 1;\n  let pickup = [cups[(currentPosition + 1) % cupsLength], cups[(currentPosition + 2) % cupsLength], cups[(currentPosition + 3) % cupsLength]];\n\n  while (pickup.includes(destination)) {\n    destination = destination - 1 < minCup ? maxCup : destination - 1;\n  }\n\n  let cupsResult = [...cups]; // cupsFiltered.splice(cupsFiltered.indexOf(destination) + 1, 3)\n  // debugger\n\n  const destinationPosition = cups.indexOf(destination);\n  let cupsFiltered = cups.filter(n => !pickup.includes(n));\n\n  if (destinationPosition > cups.indexOf(pickup[0])) {\n    cupsFiltered.splice(cupsFiltered.indexOf(destination) + 1, 0, pickup);\n    cupsResult = cupsFiltered;\n  } else {\n    cupsResult.map(a => pickup.includes(a) ? 0 : a);\n    cupsResult[destinationPosition] = pickup[2];\n    cupsResult[(cupsLength + destinationPosition - 1) % cupsLength] = pickup[1];\n    cupsResult[(cupsLength + destinationPosition - 2) % cupsLength] = pickup[0];\n    cupsResult[(cupsLength + destinationPosition - 3) % cupsLength] = destination;\n\n    while (cupsFiltered[0] !== destination) {\n      cupsFiltered = arrayRotate(cupsFiltered, true);\n    }\n\n    cupsFiltered.splice(cupsFiltered.indexOf(destination), 1);\n\n    for (let index = 0; index < cupsFiltered.length; index++) {\n      cupsResult[(cupsLength + destinationPosition - 3 - cupsFiltered.length + index) % cupsLength] = cupsFiltered[index];\n    } // debugger\n\n  }\n\n  return cupsResult.flat();\n}","map":{"version":3,"sources":["d:/Dev/adventofcode2021/src/days/jour23.js"],"names":["input","arrayRotate","result1","cups","getData","cupsMoved","NBMOVES","index","doOneMove","length","join","result2","getResultats","split","map","a","parseInt","currentPosition","cupsLength","minCup","Math","min","maxCup","max","currentCup","destination","pickup","includes","cupsResult","destinationPosition","indexOf","cupsFiltered","filter","n","splice","flat"],"mappings":"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","sourcesContent":["import { input } from \"data/input23\"\r\nimport { arrayRotate } from \"util/array\"\r\nfunction result1() {\r\n  const cups = getData()\r\n\r\n  let cupsMoved = [...cups]\r\n  const NBMOVES = 10000000\r\n  for (let index = 0; index < NBMOVES; index++) {\r\n    cupsMoved = doOneMove(cupsMoved, index % cups.length)\r\n  }\r\n\r\n  while (cupsMoved[0] !== 1) {\r\n    cupsMoved = arrayRotate(cupsMoved, true)\r\n  }\r\n  return cupsMoved.join(\"\")\r\n}\r\n\r\nfunction result2() {\r\n  return\r\n}\r\n\r\nexport default function getResultats() {\r\n  return [result1(), result2()]\r\n}\r\n\r\nfunction getData() {\r\n  return input.split(\"\").map((a) => parseInt(a))\r\n}\r\n\r\nfunction doOneMove(cups, currentPosition) {\r\n  const cupsLength = cups.length\r\n  const minCup = Math.min(...cups)\r\n  const maxCup = Math.max(...cups)\r\n  const currentCup = cups[currentPosition]\r\n  let destination = currentCup - 1 < minCup ? maxCup : currentCup - 1\r\n  let pickup = [\r\n    cups[(currentPosition + 1) % cupsLength],\r\n    cups[(currentPosition + 2) % cupsLength],\r\n    cups[(currentPosition + 3) % cupsLength],\r\n  ]\r\n  while (pickup.includes(destination)) {\r\n    destination = destination - 1 < minCup ? maxCup : destination - 1\r\n  }\r\n  let cupsResult = [...cups]\r\n  // cupsFiltered.splice(cupsFiltered.indexOf(destination) + 1, 3)\r\n  // debugger\r\n  const destinationPosition = cups.indexOf(destination)\r\n  let cupsFiltered = cups.filter((n) => !pickup.includes(n))\r\n  if (destinationPosition > cups.indexOf(pickup[0])) {\r\n    cupsFiltered.splice(cupsFiltered.indexOf(destination) + 1, 0, pickup)\r\n    cupsResult = cupsFiltered\r\n  } else {\r\n    cupsResult.map((a) => (pickup.includes(a) ? 0 : a))\r\n    cupsResult[destinationPosition] = pickup[2]\r\n\r\n    cupsResult[(cupsLength + destinationPosition - 1) % cupsLength] = pickup[1]\r\n    cupsResult[(cupsLength + destinationPosition - 2) % cupsLength] = pickup[0]\r\n    cupsResult[\r\n      (cupsLength + destinationPosition - 3) % cupsLength\r\n    ] = destination\r\n\r\n    while (cupsFiltered[0] !== destination) {\r\n      cupsFiltered = arrayRotate(cupsFiltered, true)\r\n    }\r\n    cupsFiltered.splice(cupsFiltered.indexOf(destination), 1)\r\n    for (let index = 0; index < cupsFiltered.length; index++) {\r\n      cupsResult[\r\n        (cupsLength + destinationPosition - 3 - cupsFiltered.length + index) %\r\n          cupsLength\r\n      ] = cupsFiltered[index]\r\n    }\r\n    // debugger\r\n  }\r\n  return cupsResult.flat()\r\n}\r\n"]},"metadata":{},"sourceType":"module"}