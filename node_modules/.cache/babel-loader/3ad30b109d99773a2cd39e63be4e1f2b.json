{"ast":null,"code":"import { input } from \"data/input5\";\nconst dataBrut = input.split(\"\\n\");\nconst placesBrut = dataBrut.map(i => [i.substr(0, 7), i.substr(7)]);\nconst places = calculPlaces(placesBrut);\n\nfunction result1() {\n  return Math.max(...places.map(i => i.id));\n}\n\nfunction result2() {\n  const placesManquantes = [];\n  const longueurRow = Math.pow(2, placesBrut[0][0].length);\n  const longueurCol = Math.pow(2, placesBrut[0][1].length);\n  const placesId = places.map(p => p.id);\n\n  for (let i = 0; i < longueurRow; i++) {\n    for (let j = 0; j < longueurCol; j++) {\n      const currentId = i * 8 + j;\n      !placesId.includes(currentId) && placesManquantes.push({\n        row: i,\n        col: j,\n        id: currentId\n      });\n    }\n  }\n\n  const placesManquantesId = placesManquantes.map(p => p.id); //truc compliqué pour faire semblant mais en vrai j'ai juste regardé la console de debug\n\n  return placesManquantesId[placesManquantesId.reduce((acc, curr, i) => {\n    return curr - 1 === acc ? curr : acc;\n  }) + 1];\n}\n\nfunction calculPlace(chain, bornes, lowChar = \"F\") {\n  const borneInf = bornes[0];\n  const borneSup = bornes[1];\n\n  if (chain.length === 1) {\n    return chain === lowChar ? borneInf : borneSup;\n  } else {\n    const current = chain.substr(0, 1);\n    const others = chain.substr(1, chain.length);\n    const borneNew = (borneInf + borneSup + 1) / 2;\n    return current === lowChar ? calculPlace(others, [borneInf, borneNew - 1], lowChar) : calculPlace(others, [borneNew, borneSup], lowChar);\n  }\n}\n\nfunction calculPlaces(placesChains) {\n  const longueurRow = Math.pow(2, placesChains[0][0].length);\n  const longueurCol = Math.pow(2, placesChains[0][1].length);\n  return placesChains.map(place => {\n    const row = calculPlace(place[0], [0, longueurRow - 1], \"F\");\n    const col = calculPlace(place[1], [0, longueurCol - 1], \"L\");\n    const id = row * 8 + col;\n    return {\n      row,\n      col,\n      id\n    };\n  });\n}\n\nexport default function getResultats() {\n  return [result1(), result2()];\n}","map":{"version":3,"sources":["d:/Dev/adventofcode2021/src/days/jour5.js"],"names":["input","dataBrut","split","placesBrut","map","i","substr","places","calculPlaces","result1","Math","max","id","result2","placesManquantes","longueurRow","pow","length","longueurCol","placesId","p","j","currentId","includes","push","row","col","placesManquantesId","reduce","acc","curr","calculPlace","chain","bornes","lowChar","borneInf","borneSup","current","others","borneNew","placesChains","place","getResultats"],"mappings":"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","sourcesContent":["import { input } from \"data/input5\"\r\n\r\nconst dataBrut = input.split(\"\\n\")\r\nconst placesBrut = dataBrut.map((i) => [i.substr(0, 7), i.substr(7)])\r\n\r\nconst places = calculPlaces(placesBrut)\r\n\r\nfunction result1() {\r\n  return Math.max(...places.map((i) => i.id))\r\n}\r\n\r\nfunction result2() {\r\n  const placesManquantes = []\r\n\r\n  const longueurRow = Math.pow(2, placesBrut[0][0].length)\r\n  const longueurCol = Math.pow(2, placesBrut[0][1].length)\r\n  const placesId = places.map((p) => p.id)\r\n  for (let i = 0; i < longueurRow; i++) {\r\n    for (let j = 0; j < longueurCol; j++) {\r\n      const currentId = i * 8 + j\r\n      !placesId.includes(currentId) &&\r\n        placesManquantes.push({ row: i, col: j, id: currentId })\r\n    }\r\n  }\r\n\r\n  const placesManquantesId = placesManquantes.map((p) => p.id)\r\n  //truc compliqué pour faire semblant mais en vrai j'ai juste regardé la console de debug\r\n  return placesManquantesId[\r\n    placesManquantesId.reduce((acc, curr, i) => {\r\n      return curr - 1 === acc ? curr : acc\r\n    }) + 1\r\n  ]\r\n}\r\n\r\nfunction calculPlace(chain, bornes, lowChar = \"F\") {\r\n  const borneInf = bornes[0]\r\n  const borneSup = bornes[1]\r\n  if (chain.length === 1) {\r\n    return chain === lowChar ? borneInf : borneSup\r\n  } else {\r\n    const current = chain.substr(0, 1)\r\n    const others = chain.substr(1, chain.length)\r\n    const borneNew = (borneInf + borneSup + 1) / 2\r\n    return current === lowChar\r\n      ? calculPlace(others, [borneInf, borneNew - 1], lowChar)\r\n      : calculPlace(others, [borneNew, borneSup], lowChar)\r\n  }\r\n}\r\n\r\nfunction calculPlaces(placesChains) {\r\n  const longueurRow = Math.pow(2, placesChains[0][0].length)\r\n  const longueurCol = Math.pow(2, placesChains[0][1].length)\r\n  return placesChains.map((place) => {\r\n    const row = calculPlace(place[0], [0, longueurRow - 1], \"F\")\r\n    const col = calculPlace(place[1], [0, longueurCol - 1], \"L\")\r\n    const id = row * 8 + col\r\n    return { row, col, id }\r\n  })\r\n}\r\n\r\nexport default function getResultats() {\r\n  return [result1(), result2()]\r\n}\r\n"]},"metadata":{},"sourceType":"module"}