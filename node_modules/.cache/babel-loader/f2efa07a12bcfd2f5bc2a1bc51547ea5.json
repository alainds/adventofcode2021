{"ast":null,"code":"import { input } from \"data/input13\";\nimport { plusProcheMultipleSuivant, lcmArray, bigIntMax, plusProcheMultipleSuivantBigInt, plusProcheMultipleBigInt, lcm } from \"util/math\";\nconst dataBrut = input.split(\"\\n\");\nconst now = BigInt(dataBrut[0]);\n\nfunction result1() {\n  const buses = getBuses();\n  const nextBuses = buses.map(b => b.id).map(id => {\n    return {\n      timestamp: plusProcheMultipleSuivantBigInt(now, id),\n      id\n    };\n  }).sort((a, b) => Number(a.timestamp - b.timestamp));\n  return Number((nextBuses[0].timestamp - now) * nextBuses[0].id);\n}\n\nfunction result2() {\n  const premierBus = getBuses().reduce(reducer, {\n    id: 1n,\n    i: 0n\n  });\n  return Number(premierBus.id - premierBus.i);\n} //algo élégant mais plagié ailleurs et adapté... ¯\\_(ツ)_/¯\n\n\nfunction reducer(bus1, bus2) {\n  let lePlusTot = bus1.id - bus1.i;\n\n  while ((lePlusTot + bus2.i) % bus2.id !== 0n) {\n    lePlusTot = lePlusTot + bus1.id;\n  }\n\n  const ppcm = lcm(bus1.id, bus2.id);\n  return {\n    i: ppcm - lePlusTot,\n    id: ppcm\n  };\n}\n\nexport default function getResultats() {\n  return [result1(), result2()];\n}\n\nfunction getBuses() {\n  return dataBrut[1].split(\",\").map((a, i) => {\n    return {\n      id: a,\n      i\n    };\n  }).filter(a => a.id !== \"x\").map(a => {\n    return {\n      id: BigInt(a.id),\n      i: BigInt(a.i)\n    };\n  });\n}","map":{"version":3,"sources":["d:/Dev/adventofcode2021/src/days/jour13.js"],"names":["input","plusProcheMultipleSuivant","lcmArray","bigIntMax","plusProcheMultipleSuivantBigInt","plusProcheMultipleBigInt","lcm","dataBrut","split","now","BigInt","result1","buses","getBuses","nextBuses","map","b","id","timestamp","sort","a","Number","result2","premierBus","reduce","reducer","i","bus1","bus2","lePlusTot","ppcm","getResultats","filter"],"mappings":"AAAA,SAASA,KAAT,QAAsB,cAAtB;AACA,SACEC,yBADF,EAEEC,QAFF,EAGEC,SAHF,EAIEC,+BAJF,EAKEC,wBALF,EAMEC,GANF,QAOO,WAPP;AASA,MAAMC,QAAQ,GAAGP,KAAK,CAACQ,KAAN,CAAY,IAAZ,CAAjB;AACA,MAAMC,GAAG,GAAGC,MAAM,CAACH,QAAQ,CAAC,CAAD,CAAT,CAAlB;;AACA,SAASI,OAAT,GAAmB;AACjB,QAAMC,KAAK,GAAGC,QAAQ,EAAtB;AACA,QAAMC,SAAS,GAAGF,KAAK,CACpBG,GADe,CACVC,CAAD,IAAOA,CAAC,CAACC,EADE,EAEfF,GAFe,CAEVE,EAAD,IAAQ;AACX,WAAO;AAAEC,MAAAA,SAAS,EAAEd,+BAA+B,CAACK,GAAD,EAAMQ,EAAN,CAA5C;AAAuDA,MAAAA;AAAvD,KAAP;AACD,GAJe,EAKfE,IALe,CAKV,CAACC,CAAD,EAAIJ,CAAJ,KAAUK,MAAM,CAACD,CAAC,CAACF,SAAF,GAAcF,CAAC,CAACE,SAAjB,CALN,CAAlB;AAMA,SAAOG,MAAM,CAAC,CAACP,SAAS,CAAC,CAAD,CAAT,CAAaI,SAAb,GAAyBT,GAA1B,IAAiCK,SAAS,CAAC,CAAD,CAAT,CAAaG,EAA/C,CAAb;AACD;;AAED,SAASK,OAAT,GAAmB;AACjB,QAAMC,UAAU,GAAGV,QAAQ,GAAGW,MAAX,CAAkBC,OAAlB,EAA2B;AAAER,IAAAA,EAAE,EAAE,EAAN;AAAUS,IAAAA,CAAC,EAAE;AAAb,GAA3B,CAAnB;AACA,SAAOL,MAAM,CAACE,UAAU,CAACN,EAAX,GAAgBM,UAAU,CAACG,CAA5B,CAAb;AACD,C,CAED;;;AACA,SAASD,OAAT,CAAiBE,IAAjB,EAAuBC,IAAvB,EAA6B;AAC3B,MAAIC,SAAS,GAAGF,IAAI,CAACV,EAAL,GAAUU,IAAI,CAACD,CAA/B;;AACA,SAAO,CAACG,SAAS,GAAGD,IAAI,CAACF,CAAlB,IAAuBE,IAAI,CAACX,EAA5B,KAAmC,EAA1C,EAA8C;AAC5CY,IAAAA,SAAS,GAAGA,SAAS,GAAGF,IAAI,CAACV,EAA7B;AACD;;AACD,QAAMa,IAAI,GAAGxB,GAAG,CAACqB,IAAI,CAACV,EAAN,EAAUW,IAAI,CAACX,EAAf,CAAhB;AACA,SAAO;AAAES,IAAAA,CAAC,EAAEI,IAAI,GAAGD,SAAZ;AAAuBZ,IAAAA,EAAE,EAAEa;AAA3B,GAAP;AACD;;AAED,eAAe,SAASC,YAAT,GAAwB;AACrC,SAAO,CAACpB,OAAO,EAAR,EAAYW,OAAO,EAAnB,CAAP;AACD;;AAED,SAAST,QAAT,GAAoB;AAClB,SAAON,QAAQ,CAAC,CAAD,CAAR,CACJC,KADI,CACE,GADF,EAEJO,GAFI,CAEA,CAACK,CAAD,EAAIM,CAAJ,KAAU;AACb,WAAO;AAAET,MAAAA,EAAE,EAAEG,CAAN;AAASM,MAAAA;AAAT,KAAP;AACD,GAJI,EAKJM,MALI,CAKIZ,CAAD,IAAOA,CAAC,CAACH,EAAF,KAAS,GALnB,EAMJF,GANI,CAMCK,CAAD,IAAO;AACV,WAAO;AAAEH,MAAAA,EAAE,EAAEP,MAAM,CAACU,CAAC,CAACH,EAAH,CAAZ;AAAoBS,MAAAA,CAAC,EAAEhB,MAAM,CAACU,CAAC,CAACM,CAAH;AAA7B,KAAP;AACD,GARI,CAAP;AASD","sourcesContent":["import { input } from \"data/input13\"\r\nimport {\r\n  plusProcheMultipleSuivant,\r\n  lcmArray,\r\n  bigIntMax,\r\n  plusProcheMultipleSuivantBigInt,\r\n  plusProcheMultipleBigInt,\r\n  lcm,\r\n} from \"util/math\"\r\n\r\nconst dataBrut = input.split(\"\\n\")\r\nconst now = BigInt(dataBrut[0])\r\nfunction result1() {\r\n  const buses = getBuses()\r\n  const nextBuses = buses\r\n    .map((b) => b.id)\r\n    .map((id) => {\r\n      return { timestamp: plusProcheMultipleSuivantBigInt(now, id), id }\r\n    })\r\n    .sort((a, b) => Number(a.timestamp - b.timestamp))\r\n  return Number((nextBuses[0].timestamp - now) * nextBuses[0].id)\r\n}\r\n\r\nfunction result2() {\r\n  const premierBus = getBuses().reduce(reducer, { id: 1n, i: 0n })\r\n  return Number(premierBus.id - premierBus.i)\r\n}\r\n\r\n//algo élégant mais plagié ailleurs et adapté... ¯\\_(ツ)_/¯\r\nfunction reducer(bus1, bus2) {\r\n  let lePlusTot = bus1.id - bus1.i\r\n  while ((lePlusTot + bus2.i) % bus2.id !== 0n) {\r\n    lePlusTot = lePlusTot + bus1.id\r\n  }\r\n  const ppcm = lcm(bus1.id, bus2.id)\r\n  return { i: ppcm - lePlusTot, id: ppcm }\r\n}\r\n\r\nexport default function getResultats() {\r\n  return [result1(), result2()]\r\n}\r\n\r\nfunction getBuses() {\r\n  return dataBrut[1]\r\n    .split(\",\")\r\n    .map((a, i) => {\r\n      return { id: a, i }\r\n    })\r\n    .filter((a) => a.id !== \"x\")\r\n    .map((a) => {\r\n      return { id: BigInt(a.id), i: BigInt(a.i) }\r\n    })\r\n}\r\n"]},"metadata":{},"sourceType":"module"}