{"ast":null,"code":"import { input } from \"data/input16\";\nimport { intersectArray, reducerMultiply, reducerSum, getNbOccurrence } from \"util/array\";\nimport { uniq } from \"lodash\";\n\nfunction result1() {\n  const {\n    infos,\n    nearbyTickets\n  } = getInfosTickets();\n  return nearbyTickets.map(ticket => getTicketErrorRate(ticket, infos)).reduce(reducerSum);\n}\n\nfunction result2() {\n  const {\n    infos,\n    ticket,\n    nearbyTickets\n  } = getInfosTickets();\n  const validTickets = nearbyTickets.filter(ticket => getTicketErrorRate(ticket, infos) === 0);\n  const validTicketsWithValidInfo = validTickets.map(ticket => ticket.map(v => getValidInfos(v, infos)));\n  let infosPositions = {\n    duration: 1\n  }; //hack : duration en 1 car il est nul part sinon\n\n  const infosNames = Object.keys(infos);\n  let namesByPosition = [];\n\n  for (let index = 0; index < validTicketsWithValidInfo[0].length; index++) {\n    const nameInCommon = validTicketsWithValidInfo.map((a, i) => a[index]).reduce(intersectArray, infosNames);\n    namesByPosition[index] = nameInCommon;\n  }\n\n  while (namesByPosition.filter(a => a.length > 0).length > 0) {\n    namesByPosition = namesByPosition.map((a, i) => !Object.values(infosPositions).includes(i) ? a.filter(name => !Object.keys(infosPositions).includes(name)) : []);\n    const allNames = namesByPosition.filter(a => a.length > 0).flat();\n    const uniqueNames = uniq(allNames).map(name => {\n      return {\n        name,\n        count: getNbOccurrence(allNames, name)\n      };\n    }).filter(a => a.count === 1).map(a => a.name);\n    namesByPosition.forEach((nameInCommon, index) => {\n      const intersect = intersectArray(uniqueNames, nameInCommon);\n      if (intersect.length === 1) infosPositions[intersect[0]] = index;\n    });\n  }\n\n  const departuresPositions = [];\n\n  for (const [cle, valeur] of Object.entries(infosPositions)) {\n    if (cle.includes(\"departure\")) departuresPositions.push(valeur);\n  }\n\n  return ticket.filter((t, i) => departuresPositions.includes(i)).reduce(reducerMultiply);\n}\n\nexport default function getResultats() {\n  return [result1(), result2()];\n}\n\nfunction getInfosTickets() {\n  const dataBrut = input.split(\"\\n\\n\");\n  const regexInfo = new RegExp(\"^(.*): ([0-9]*)-([0-9]*) or ([0-9]*)-([0-9]*)$\");\n  const infosArr = dataBrut[0].split(\"\\n\").map(infodata => {\n    const regexExec = regexInfo.exec(infodata);\n    const name = regexExec[1].replace(\" \", \"\");\n    const info = [name, {\n      range1: [parseInt(regexExec[2]), parseInt(regexExec[3])],\n      range2: [parseInt(regexExec[4]), parseInt(regexExec[5])]\n    }];\n    return info;\n  });\n  const infos = Object.fromEntries(infosArr);\n  const ticket = dataBrut[1].split(\"\\n\").filter((a, i) => i > 0)[0].split(\",\").map(a => parseInt(a));\n  const nearbyTickets = dataBrut[2].split(\"\\n\").filter((a, i) => i > 0).map(ticket => ticket.split(\",\").map(a => parseInt(a)));\n  return {\n    infos,\n    ticket,\n    nearbyTickets\n  };\n}\n\nfunction isValid(value, info) {\n  return value >= info.range1[0] && value <= info.range1[1] || value >= info.range2[0] && value <= info.range2[1];\n}\n\nfunction getValidInfos(value, infos) {\n  return Object.keys(infos).filter(infoName => isValid(value, infos[infoName]));\n}\n\nfunction isValidValue(value, infos) {\n  return Object.keys(infos).filter(infoName => isValid(value, infos[infoName])).length > 0;\n}\n\nfunction getTicketErrorRate(ticket, infos) {\n  return ticket.map(v => isValidValue(v, infos) ? 0 : v).reduce(reducerSum);\n}","map":{"version":3,"sources":["d:/Dev/adventofcode2021/src/days/jour16.js"],"names":["input","intersectArray","reducerMultiply","reducerSum","getNbOccurrence","uniq","result1","infos","nearbyTickets","getInfosTickets","map","ticket","getTicketErrorRate","reduce","result2","validTickets","filter","validTicketsWithValidInfo","v","getValidInfos","infosPositions","duration","infosNames","Object","keys","namesByPosition","index","length","nameInCommon","a","i","values","includes","name","allNames","flat","uniqueNames","count","forEach","intersect","departuresPositions","cle","valeur","entries","push","t","getResultats","dataBrut","split","regexInfo","RegExp","infosArr","infodata","regexExec","exec","replace","info","range1","parseInt","range2","fromEntries","isValid","value","infoName","isValidValue"],"mappings":"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","sourcesContent":["import { input } from \"data/input16\"\r\nimport {\r\n  intersectArray,\r\n  reducerMultiply,\r\n  reducerSum,\r\n  getNbOccurrence,\r\n} from \"util/array\"\r\n\r\nimport { uniq } from \"lodash\"\r\nfunction result1() {\r\n  const { infos, nearbyTickets } = getInfosTickets()\r\n\r\n  return nearbyTickets\r\n    .map((ticket) => getTicketErrorRate(ticket, infos))\r\n    .reduce(reducerSum)\r\n}\r\n\r\nfunction result2() {\r\n  const { infos, ticket, nearbyTickets } = getInfosTickets()\r\n  const validTickets = nearbyTickets.filter(\r\n    (ticket) => getTicketErrorRate(ticket, infos) === 0\r\n  )\r\n  const validTicketsWithValidInfo = validTickets.map((ticket) =>\r\n    ticket.map((v) => getValidInfos(v, infos))\r\n  )\r\n\r\n  let infosPositions = { duration: 1 } //hack : duration en 1 car il est nul part sinon\r\n  const infosNames = Object.keys(infos)\r\n  let namesByPosition = []\r\n  for (let index = 0; index < validTicketsWithValidInfo[0].length; index++) {\r\n    const nameInCommon = validTicketsWithValidInfo\r\n      .map((a, i) => a[index])\r\n      .reduce(intersectArray, infosNames)\r\n    namesByPosition[index] = nameInCommon\r\n  }\r\n  while (namesByPosition.filter((a) => a.length > 0).length > 0) {\r\n    namesByPosition = namesByPosition.map((a, i) =>\r\n      !Object.values(infosPositions).includes(i)\r\n        ? a.filter((name) => !Object.keys(infosPositions).includes(name))\r\n        : []\r\n    )\r\n    const allNames = namesByPosition.filter((a) => a.length > 0).flat()\r\n    const uniqueNames = uniq(allNames)\r\n      .map((name) => {\r\n        return { name, count: getNbOccurrence(allNames, name) }\r\n      })\r\n      .filter((a) => a.count === 1)\r\n      .map((a) => a.name)\r\n\r\n    namesByPosition.forEach((nameInCommon, index) => {\r\n      const intersect = intersectArray(uniqueNames, nameInCommon)\r\n      if (intersect.length === 1) infosPositions[intersect[0]] = index\r\n    })\r\n  }\r\n  const departuresPositions = []\r\n  for (const [cle, valeur] of Object.entries(infosPositions)) {\r\n    if (cle.includes(\"departure\")) departuresPositions.push(valeur)\r\n  }\r\n  return ticket\r\n    .filter((t, i) => departuresPositions.includes(i))\r\n    .reduce(reducerMultiply)\r\n}\r\n\r\nexport default function getResultats() {\r\n  return [result1(), result2()]\r\n}\r\n\r\nfunction getInfosTickets() {\r\n  const dataBrut = input.split(\"\\n\\n\")\r\n  const regexInfo = new RegExp(\"^(.*): ([0-9]*)-([0-9]*) or ([0-9]*)-([0-9]*)$\")\r\n  const infosArr = dataBrut[0].split(\"\\n\").map((infodata) => {\r\n    const regexExec = regexInfo.exec(infodata)\r\n    const name = regexExec[1].replace(\" \", \"\")\r\n    const info = [\r\n      name,\r\n      {\r\n        range1: [parseInt(regexExec[2]), parseInt(regexExec[3])],\r\n        range2: [parseInt(regexExec[4]), parseInt(regexExec[5])],\r\n      },\r\n    ]\r\n    return info\r\n  })\r\n  const infos = Object.fromEntries(infosArr)\r\n  const ticket = dataBrut[1]\r\n    .split(\"\\n\")\r\n    .filter((a, i) => i > 0)[0]\r\n    .split(\",\")\r\n    .map((a) => parseInt(a))\r\n  const nearbyTickets = dataBrut[2]\r\n    .split(\"\\n\")\r\n    .filter((a, i) => i > 0)\r\n    .map((ticket) => ticket.split(\",\").map((a) => parseInt(a)))\r\n  return { infos, ticket, nearbyTickets }\r\n}\r\n\r\nfunction isValid(value, info) {\r\n  return (\r\n    (value >= info.range1[0] && value <= info.range1[1]) ||\r\n    (value >= info.range2[0] && value <= info.range2[1])\r\n  )\r\n}\r\n\r\nfunction getValidInfos(value, infos) {\r\n  return Object.keys(infos).filter((infoName) =>\r\n    isValid(value, infos[infoName])\r\n  )\r\n}\r\n\r\nfunction isValidValue(value, infos) {\r\n  return (\r\n    Object.keys(infos).filter((infoName) => isValid(value, infos[infoName]))\r\n      .length > 0\r\n  )\r\n}\r\nfunction getTicketErrorRate(ticket, infos) {\r\n  return ticket.map((v) => (isValidValue(v, infos) ? 0 : v)).reduce(reducerSum)\r\n}\r\n"]},"metadata":{},"sourceType":"module"}